Directory structure:
└── javascript/
    ├── README.md
    ├── build.rs
    ├── Cargo.toml
    ├── index.d.ts
    ├── index.js
    ├── package.json
    ├── sqlite-error.js
    ├── wrapper.js
    ├── .npmignore
    ├── .yarnrc.yml
    ├── __test__/
    │   ├── better-sqlite3.spec.mjs
    │   ├── dual-test.mjs
    │   ├── sync.spec.mjs
    │   └── artifacts/
    │       └── basic-test.sql
    ├── docs/
    │   ├── API.md
    │   └── CONTRIBUTING.md
    ├── examples/
    │   └── drizzle/
    │       ├── example.js
    │       └── package.json
    ├── npm/
    │   ├── darwin-universal/
    │   │   ├── README.md
    │   │   └── package.json
    │   ├── linux-x64-gnu/
    │   │   ├── README.md
    │   │   └── package.json
    │   └── win32-x64-msvc/
    │       ├── README.md
    │       └── package.json
    └── src/
        └── lib.rs


Files Content:

================================================
FILE: bindings/javascript/README.md
================================================
# @tursodatabase/turso

The next evolution of SQLite: A high-performance, SQLite-compatible database library for Node.js

## Features

- **SQLite Compatible**: Drop-in replacement for better-sqlite3 with familiar API
- **High Performance**: Built with Rust for maximum speed and efficiency  
- **In-Process**: No network overhead, runs directly in your Node.js process
- **TypeScript Support**: Full TypeScript definitions included
- **Cross-Platform**: Supports Linux, macOS, and Windows
- **Transaction Support**: Full ACID transactions with rollback support
- **Prepared Statements**: Optimized query execution with parameter binding

## Installation

```bash
npm install @tursodatabase/turso
```

## Quick Start

### In-Memory Database

```javascript
import Database from '@tursodatabase/turso';

// Create an in-memory database
const db = new Database(':memory:');

// Create a table
db.exec('CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)');

// Insert data
const insert = db.prepare('INSERT INTO users (name, email) VALUES (?, ?)');
insert.run('Alice', 'alice@example.com');
insert.run('Bob', 'bob@example.com');

// Query data
const users = db.prepare('SELECT * FROM users').all();
console.log(users);
// Output: [
//   { id: 1, name: 'Alice', email: 'alice@example.com' },
//   { id: 2, name: 'Bob', email: 'bob@example.com' }
// ]
```

### File-Based Database

```javascript
import Database from '@tursodatabase/turso';

// Create or open a database file
const db = new Database('my-database.db');

// Create a table
db.exec(`
  CREATE TABLE IF NOT EXISTS posts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    content TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )
`);

// Insert a post
const insertPost = db.prepare('INSERT INTO posts (title, content) VALUES (?, ?)');
const result = insertPost.run('Hello World', 'This is my first blog post!');

console.log(`Inserted post with ID: ${result.lastInsertRowid}`);
```

## API Reference
## License

MIT

## Support

- [GitHub Issues](https://github.com/tursodatabase/turso/issues)
- [Documentation](https://docs.turso.tech)
- [Discord Community](https://discord.gg/turso)



================================================
FILE: bindings/javascript/build.rs
================================================
extern crate napi_build;

fn main() {
    napi_build::setup();
}



================================================
FILE: bindings/javascript/Cargo.toml
================================================
[package]
name = "turso_node"
version.workspace = true
authors.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
description = "The Turso database library Node bindings"

[lib]
crate-type = ["cdylib"]

[dependencies]
turso_core = { workspace = true }
napi = { version = "3.1.3", default-features = false }
napi-derive = { version = "3.1.1", default-features = true }

[build-dependencies]
napi-build = "2.2.3"



================================================
FILE: bindings/javascript/index.d.ts
================================================
/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Database {
  memory: boolean
  readonly: boolean
  open: boolean
  name: string
  constructor(path: string, options?: OpenDatabaseOptions | undefined | null)
  prepare(sql: string): Statement
  pragma(pragmaName: string, options?: PragmaOptions | undefined | null): unknown
  backup(): void
  serialize(): void
  function(): void
  aggregate(): void
  table(): void
  loadExtension(path: string): void
  exec(sql: string): void
  close(): void
}

export declare class Statement {
  source: string
  get(args?: Array<unknown> | undefined | null): unknown
  run(args?: Array<unknown> | undefined | null): RunResult
  all(args?: Array<unknown> | undefined | null): unknown
  pluck(pluck?: boolean | undefined | null): void
  static expand(): void
  raw(raw?: boolean | undefined | null): void
  static columns(): void
  bind(args?: Array<unknown> | undefined | null): Statement
}

export interface OpenDatabaseOptions {
  readonly?: boolean
  fileMustExist?: boolean
  timeout?: number
}

export interface PragmaOptions {
  simple: boolean
}

export interface RunResult {
  changes: number
  lastInsertRowid: number
}



================================================
FILE: bindings/javascript/index.js
================================================
// prettier-ignore
/* eslint-disable */
// @ts-nocheck
/* auto-generated by NAPI-RS */

const { createRequire } = require('node:module')
require = createRequire(__filename)

const { readFileSync } = require('node:fs')
let nativeBinding = null
const loadErrors = []

const isMusl = () => {
  let musl = false
  if (process.platform === 'linux') {
    musl = isMuslFromFilesystem()
    if (musl === null) {
      musl = isMuslFromReport()
    }
    if (musl === null) {
      musl = isMuslFromChildProcess()
    }
  }
  return musl
}

const isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-')

const isMuslFromFilesystem = () => {
  try {
    return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl')
  } catch {
    return null
  }
}

const isMuslFromReport = () => {
  let report = null
  if (typeof process.report?.getReport === 'function') {
    process.report.excludeNetwork = true
    report = process.report.getReport()
  }
  if (!report) {
    return null
  }
  if (report.header && report.header.glibcVersionRuntime) {
    return false
  }
  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return true
    }
  }
  return false
}

const isMuslFromChildProcess = () => {
  try {
    return require('child_process').execSync('ldd --version', { encoding: 'utf8' }).includes('musl')
  } catch (e) {
    // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
    return false
  }
}

function requireNative() {
  if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
    try {
      nativeBinding = require(process.env.NAPI_RS_NATIVE_LIBRARY_PATH);
    } catch (err) {
      loadErrors.push(err)
    }
  } else if (process.platform === 'android') {
    if (process.arch === 'arm64') {
      try {
        return require('./turso.android-arm64.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-android-arm64')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'arm') {
      try {
        return require('./turso.android-arm-eabi.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-android-arm-eabi')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on Android ${process.arch}`))
    }
  } else if (process.platform === 'win32') {
    if (process.arch === 'x64') {
      try {
        return require('./turso.win32-x64-msvc.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-win32-x64-msvc')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'ia32') {
      try {
        return require('./turso.win32-ia32-msvc.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-win32-ia32-msvc')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'arm64') {
      try {
        return require('./turso.win32-arm64-msvc.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-win32-arm64-msvc')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on Windows: ${process.arch}`))
    }
  } else if (process.platform === 'darwin') {
    try {
      return require('./turso.darwin-universal.node')
    } catch (e) {
      loadErrors.push(e)
    }
    try {
      return require('@tursodatabase/turso-darwin-universal')
    } catch (e) {
      loadErrors.push(e)
    }
    if (process.arch === 'x64') {
      try {
        return require('./turso.darwin-x64.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-darwin-x64')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'arm64') {
      try {
        return require('./turso.darwin-arm64.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-darwin-arm64')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on macOS: ${process.arch}`))
    }
  } else if (process.platform === 'freebsd') {
    if (process.arch === 'x64') {
      try {
        return require('./turso.freebsd-x64.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-freebsd-x64')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'arm64') {
      try {
        return require('./turso.freebsd-arm64.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-freebsd-arm64')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on FreeBSD: ${process.arch}`))
    }
  } else if (process.platform === 'linux') {
    if (process.arch === 'x64') {
      if (isMusl()) {
        try {
          return require('./turso.linux-x64-musl.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@tursodatabase/turso-linux-x64-musl')
        } catch (e) {
          loadErrors.push(e)
        }
      } else {
        try {
          return require('./turso.linux-x64-gnu.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@tursodatabase/turso-linux-x64-gnu')
        } catch (e) {
          loadErrors.push(e)
        }
      }
    } else if (process.arch === 'arm64') {
      if (isMusl()) {
        try {
          return require('./turso.linux-arm64-musl.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@tursodatabase/turso-linux-arm64-musl')
        } catch (e) {
          loadErrors.push(e)
        }
      } else {
        try {
          return require('./turso.linux-arm64-gnu.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@tursodatabase/turso-linux-arm64-gnu')
        } catch (e) {
          loadErrors.push(e)
        }
      }
    } else if (process.arch === 'arm') {
      if (isMusl()) {
        try {
          return require('./turso.linux-arm-musleabihf.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@tursodatabase/turso-linux-arm-musleabihf')
        } catch (e) {
          loadErrors.push(e)
        }
      } else {
        try {
          return require('./turso.linux-arm-gnueabihf.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@tursodatabase/turso-linux-arm-gnueabihf')
        } catch (e) {
          loadErrors.push(e)
        }
      }
    } else if (process.arch === 'riscv64') {
      if (isMusl()) {
        try {
          return require('./turso.linux-riscv64-musl.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@tursodatabase/turso-linux-riscv64-musl')
        } catch (e) {
          loadErrors.push(e)
        }
      } else {
        try {
          return require('./turso.linux-riscv64-gnu.node')
        } catch (e) {
          loadErrors.push(e)
        }
        try {
          return require('@tursodatabase/turso-linux-riscv64-gnu')
        } catch (e) {
          loadErrors.push(e)
        }
      }
    } else if (process.arch === 'ppc64') {
      try {
        return require('./turso.linux-ppc64-gnu.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-linux-ppc64-gnu')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 's390x') {
      try {
        return require('./turso.linux-s390x-gnu.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-linux-s390x-gnu')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on Linux: ${process.arch}`))
    }
  } else if (process.platform === 'openharmony') {
    if (process.arch === 'arm64') {
      try {
        return require('./turso.linux-arm64-ohos.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-linux-arm64-ohos')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'x64') {
      try {
        return require('./turso.linux-x64-ohos.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-linux-x64-ohos')
      } catch (e) {
        loadErrors.push(e)
      }
    } else if (process.arch === 'arm') {
      try {
        return require('./turso.linux-arm-ohos.node')
      } catch (e) {
        loadErrors.push(e)
      }
      try {
        return require('@tursodatabase/turso-linux-arm-ohos')
      } catch (e) {
        loadErrors.push(e)
      }
    } else {
      loadErrors.push(new Error(`Unsupported architecture on OpenHarmony: ${process.arch}`))
    }
  } else {
    loadErrors.push(new Error(`Unsupported OS: ${process.platform}, architecture: ${process.arch}`))
  }
}

nativeBinding = requireNative()

if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
  try {
    nativeBinding = require('./turso.wasi.cjs')
  } catch (err) {
    if (process.env.NAPI_RS_FORCE_WASI) {
      loadErrors.push(err)
    }
  }
  if (!nativeBinding) {
    try {
      nativeBinding = require('@tursodatabase/turso-wasm32-wasi')
    } catch (err) {
      if (process.env.NAPI_RS_FORCE_WASI) {
        loadErrors.push(err)
      }
    }
  }
}

if (!nativeBinding) {
  if (loadErrors.length > 0) {
    throw new Error(
      `Cannot find native binding. ` +
        `npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). ` +
        'Please try `npm i` again after removing both package-lock.json and node_modules directory.',
      { cause: loadErrors }
    )
  }
  throw new Error(`Failed to load native binding`)
}

module.exports = nativeBinding
module.exports.Database = nativeBinding.Database
module.exports.Statement = nativeBinding.Statement



================================================
FILE: bindings/javascript/package.json
================================================
{
  "name": "@tursodatabase/turso",
  "version": "0.1.3-pre.5",
  "repository": {
    "type": "git",
    "url": "https://github.com/tursodatabase/turso"
  },
  "description": "The Turso database library",
  "main": "wrapper.js",
  "types": "index.d.ts",
  "napi": {
    "binaryName": "turso",
    "targets": [
      "x86_64-unknown-linux-gnu",
      "x86_64-pc-windows-msvc",
      "universal-apple-darwin"
    ]
  },
  "license": "MIT",
  "devDependencies": {
    "@napi-rs/cli": "^3.0.4",
    "ava": "^6.0.1",
    "better-sqlite3": "^11.9.1"
  },
  "ava": {
    "timeout": "3m"
  },
  "engines": {
    "node": ">= 10"
  },
  "scripts": {
    "artifacts": "napi artifacts",
    "build": "napi build --platform --release",
    "build:debug": "napi build --platform",
    "prepublishOnly": "napi prepublish -t npm",
    "test": "ava",
    "universal": "napi universalize",
    "version": "napi version"
  },
  "packageManager": "yarn@4.9.2"
}



================================================
FILE: bindings/javascript/sqlite-error.js
================================================
'use strict';
const descriptor = { value: 'SqliteError', writable: true, enumerable: false, configurable: true };

function SqliteError(message, code, rawCode) {
        if (new.target !== SqliteError) {
                return new SqliteError(message, code);
        }
        if (typeof code !== 'string') {
                throw new TypeError('Expected second argument to be a string');
        }
        Error.call(this, message);
        descriptor.value = '' + message;
        Object.defineProperty(this, 'message', descriptor);
        Error.captureStackTrace(this, SqliteError);
        this.code = code;
        this.rawCode = rawCode
}
Object.setPrototypeOf(SqliteError, Error);
Object.setPrototypeOf(SqliteError.prototype, Error.prototype);
Object.defineProperty(SqliteError.prototype, 'name', descriptor);
module.exports = SqliteError;




================================================
FILE: bindings/javascript/wrapper.js
================================================
"use strict";

const { Database: NativeDB } = require("./index.js");

const SqliteError = require("./sqlite-error.js");

const convertibleErrorTypes = { TypeError };
const CONVERTIBLE_ERROR_PREFIX = "[TURSO_CONVERT_TYPE]";

function convertError(err) {
  if ((err.code ?? "").startsWith(CONVERTIBLE_ERROR_PREFIX)) {
    return createErrorByName(
      err.code.substring(CONVERTIBLE_ERROR_PREFIX.length),
      err.message,
    );
  }

  return new SqliteError(err.message, err.code, err.rawCode);
}

function createErrorByName(name, message) {
  const ErrorConstructor = convertibleErrorTypes[name];
  if (!ErrorConstructor) {
    throw new Error(`unknown error type ${name} from Turso`);
  }

  return new ErrorConstructor(message);
}

/**
 * Database represents a connection that can prepare and execute SQL statements.
 */
class Database {
  /**
   * Creates a new database connection. If the database file pointed to by `path` does not exists, it will be created.
   *
   * @constructor
   * @param {string} path - Path to the database file.
   * @param {Object} opts - Options for database behavior.
   * @param {boolean} [opts.readonly=false] - Open the database in read-only mode.
   * @param {boolean} [opts.fileMustExist=false] - If true, throws if database file does not exist.
   * @param {number} [opts.timeout=0] - Timeout duration in milliseconds for database operations. Defaults to 0 (no timeout).
   */
  constructor(path, opts = {}) {
    opts.readonly = opts.readonly === undefined ? false : opts.readonly;
    opts.fileMustExist =
      opts.fileMustExist === undefined ? false : opts.fileMustExist;
    opts.timeout = opts.timeout === undefined ? 0 : opts.timeout;

    this.db = new NativeDB(path, opts);
    this.memory = this.db.memory;
    const db = this.db;

    Object.defineProperties(this, {
      inTransaction: {
        get() {
          return db.inTransaction();
        },
      },
      name: {
        get() {
          return path;
        },
      },
      readonly: {
        get() {
          return opts.readonly;
        },
      },
      open: {
        get() {
          return this.db.open;
        },
      },
    });
  }

  /**
   * Prepares a SQL statement for execution.
   *
   * @param {string} sql - The SQL statement string to prepare.
   */
  prepare(sql) {
    if (!sql) {
      throw new RangeError("The supplied SQL string contains no statements");
    }

    try {
      return new Statement(this.db.prepare(sql), this);
    } catch (err) {
      throw convertError(err);
    }
  }

  /**
   * Returns a function that executes the given function in a transaction.
   *
   * @param {function} fn - The function to wrap in a transaction.
   */
  transaction(fn) {
    if (typeof fn !== "function")
      throw new TypeError("Expected first argument to be a function");

    const db = this;
    const wrapTxn = (mode) => {
      return (...bindParameters) => {
        db.exec("BEGIN " + mode);
        try {
          const result = fn(...bindParameters);
          db.exec("COMMIT");
          return result;
        } catch (err) {
          db.exec("ROLLBACK");
          throw err;
        }
      };
    };
    const properties = {
      default: { value: wrapTxn("") },
      deferred: { value: wrapTxn("DEFERRED") },
      immediate: { value: wrapTxn("IMMEDIATE") },
      exclusive: { value: wrapTxn("EXCLUSIVE") },
      database: { value: this, enumerable: true },
    };
    Object.defineProperties(properties.default.value, properties);
    Object.defineProperties(properties.deferred.value, properties);
    Object.defineProperties(properties.immediate.value, properties);
    Object.defineProperties(properties.exclusive.value, properties);
    return properties.default.value;
  }

  pragma(source, options) {
    if (options == null) options = {};

    if (typeof source !== "string")
      throw new TypeError("Expected first argument to be a string");

    if (typeof options !== "object")
      throw new TypeError("Expected second argument to be an options object");

    const simple = options["simple"];
    const pragma = `PRAGMA ${source}`;

    return simple
      ? this.db.pragma(source, { simple: true })
      : this.db.pragma(source);
  }

  backup(filename, options) {
    throw new Error("not implemented");
  }

  serialize(options) {
    throw new Error("not implemented");
  }

  function(name, options, fn) {
    throw new Error("not implemented");
  }

  aggregate(name, options) {
    throw new Error("not implemented");
  }

  table(name, factory) {
    throw new Error("not implemented");
  }

  loadExtension(path) {
    this.db.loadExtension(path);
  }

  maxWriteReplicationIndex() {
    throw new Error("not implemented");
  }

  /**
   * Executes a SQL statement.
   *
   * @param {string} sql - The SQL statement string to execute.
   */
  exec(sql) {
    try {
      this.db.exec(sql);
    } catch (err) {
      throw convertError(err);
    }
  }

  /**
   * Interrupts the database connection.
   */
  interrupt() {
    this.db.interrupt();
  }

  /**
   * Closes the database connection.
   */
  close() {
    this.db.close();
  }
}

/**
 * Statement represents a prepared SQL statement that can be executed.
 */
class Statement {
  constructor(stmt, database) {
    this.stmt = stmt;
    this.db = database;
  }

  /**
   * Toggle raw mode.
   *
   * @param raw Enable or disable raw mode. If you don't pass the parameter, raw mode is enabled.
   */
  raw(raw) {
    this.stmt.raw(raw);
    return this;
  }

  /**
   * Toggle pluck mode.
   *
   * @param pluckMode Enable or disable pluck mode. If you don't pass the parameter, pluck mode is enabled.
   */
  pluck(pluckMode) {
    this.stmt.pluck(pluckMode);
    return this;
  }

  get source() {
    return this.stmt.source;
  }

  get reader() {
    throw new Error("not implemented");
  }

  get source() {
    return this.stmt.source;
  }

  get database() {
    return this.db;
  }

  /**
   * Executes the SQL statement and returns an info object.
   */
  run(...bindParameters) {
    return this.stmt.run(bindParameters.flat());
  }

  /**
   * Executes the SQL statement and returns the first row.
   *
   * @param bindParameters - The bind parameters for executing the statement.
   */
  get(...bindParameters) {
    return this.stmt.get(bindParameters.flat());
  }

  /**
   * Executes the SQL statement and returns an iterator to the resulting rows.
   *
   * @param bindParameters - The bind parameters for executing the statement.
   */
  *iterate(...bindParameters) {
    throw new Error("not implemented");
  }

  /**
   * Executes the SQL statement and returns an array of the resulting rows.
   *
   * @param bindParameters - The bind parameters for executing the statement.
   */
  all(...bindParameters) {
    return this.stmt.all(bindParameters.flat());
  }

  /**
   * Interrupts the statement.
   */
  interrupt() {
    this.stmt.interrupt();
    return this;
  }

  /**
   * Returns the columns in the result set returned by this prepared statement.
   */
  columns() {
    return this.stmt.columns();
  }

  /**
   * Binds the given parameters to the statement _permanently_
   *
   * @param bindParameters - The bind parameters for binding the statement.
   * @returns this - Statement with binded parameters
   */
  bind(...bindParameters) {
    try {
      return new Statement(this.stmt.bind(bindParameters.flat()), this.db);
    } catch (err) {
      throw convertError(err);
    }
  }
}

module.exports = Database;
module.exports.SqliteError = SqliteError;



================================================
FILE: bindings/javascript/.npmignore
================================================
target
Cargo.lock
.cargo
.github
npm
.eslintrc
.prettierignore
rustfmt.toml
yarn.lock
*.node
.yarn
__test__
renovate.json



================================================
FILE: bindings/javascript/.yarnrc.yml
================================================
nodeLinker: node-modules

yarnPath: .yarn/releases/yarn-4.9.2.cjs
enableHardenedMode: false



================================================
FILE: bindings/javascript/__test__/better-sqlite3.spec.mjs
================================================
import crypto from "crypto";
import fs from "node:fs";
import { fileURLToPath } from "url";
import path from "node:path";
import DualTest from "./dual-test.mjs";

const inMemoryTest = new DualTest(":memory:");
const foobarTest = new DualTest("foobar.db");

inMemoryTest.both("Open in-memory database", async (t) => {
  const db = t.context.db;
  t.is(db.memory, true);
});

inMemoryTest.both("Property .name of in-memory database", async (t) => {
  const db = t.context.db;
  t.is(db.name, t.context.path);
});

foobarTest.both("Property .name of database", async (t) => {
  const db = t.context.db;
  t.is(db.name, t.context.path);
});

new DualTest("foobar.db", { readonly: true }).both(
  "Property .readonly of database if set",
  async (t) => {
    const db = t.context.db;
    t.is(db.readonly, true);
  },
);

const genDatabaseFilename = () => {
  return `test-${crypto.randomBytes(8).toString("hex")}.db`;
};

new DualTest().both(
  "opening a read-only database fails if the file doesn't exist",
  async (t) => {
    t.throws(
      () => t.context.connect(genDatabaseFilename(), { readonly: true }),
      {
        any: true,
        code: "SQLITE_CANTOPEN",
      },
    );
  },
);

foobarTest.both("Property .readonly of database if not set", async (t) => {
  const db = t.context.db;
  t.is(db.readonly, false);
});

foobarTest.both("Property .open of database", async (t) => {
  const db = t.context.db;
  t.is(db.open, true);
});

inMemoryTest.both("Statement.get() returns data", async (t) => {
  const db = t.context.db;
  const stmt = db.prepare("SELECT 1");
  const result = stmt.get();
  t.is(result["1"], 1);
  const result2 = stmt.get();
  t.is(result2["1"], 1);
});

inMemoryTest.both(
  "Statement.get() returns undefined when no data",
  async (t) => {
    const db = t.context.db;
    const stmt = db.prepare("SELECT 1 WHERE 1 = 2");
    const result = stmt.get();
    t.is(result, undefined);
  },
);

inMemoryTest.both(
  "Statement.run() returns correct result object",
  async (t) => {
    const db = t.context.db;
    db.prepare("CREATE TABLE users (name TEXT)").run();
    const rows = db.prepare("INSERT INTO users (name) VALUES (?)").run("Alice");
    t.deepEqual(rows, { changes: 1, lastInsertRowid: 1 });
  },
);

inMemoryTest.onlySqlitePasses(
  "Statment.iterate() should correctly return an iterable object",
  async (t) => {
    const db = t.context.db;
    db.prepare(
      "CREATE TABLE users (name TEXT, age INTEGER, nationality TEXT)",
    ).run();
    db.prepare(
      "INSERT INTO users (name, age, nationality) VALUES (?, ?, ?)",
    ).run(["Alice", 42], "UK");
    db.prepare(
      "INSERT INTO users (name, age, nationality) VALUES (?, ?, ?)",
    ).run("Bob", 24, "USA");

    let rows = db.prepare("SELECT * FROM users").iterate();
    for (const row of rows) {
      t.truthy(row.name);
      t.truthy(row.nationality);
      t.true(typeof row.age === "number");
    }
  },
);

inMemoryTest.both(
  "Empty prepared statement should throw the correct error",
  async (t) => {
    const db = t.context.db;
    t.throws(
      () => {
        db.prepare("");
      },
      {
        instanceOf: RangeError,
        message: "The supplied SQL string contains no statements",
      },
    );
  },
);

inMemoryTest.both("Test pragma()", async (t) => {
  const db = t.context.db;
  t.deepEqual(typeof db.pragma("cache_size")[0].cache_size, "number");
  t.deepEqual(typeof db.pragma("cache_size", { simple: true }), "number");
});

inMemoryTest.both("pragma query", async (t) => {
  const db = t.context.db;
  let page_size = db.pragma("page_size");
  let expectedValue = [{ page_size: 4096 }];
  t.deepEqual(page_size, expectedValue);
});

inMemoryTest.both("pragma table_list", async (t) => {
  const db = t.context.db;
  let param = "sqlite_schema";
  let actual = db.pragma(`table_info(${param})`);
  let expectedValue = [
    { cid: 0, name: "type", type: "TEXT", notnull: 0, dflt_value: null, pk: 0 },
    { cid: 1, name: "name", type: "TEXT", notnull: 0, dflt_value: null, pk: 0 },
    {
      cid: 2,
      name: "tbl_name",
      type: "TEXT",
      notnull: 0,
      dflt_value: null,
      pk: 0,
    },
    {
      cid: 3,
      name: "rootpage",
      type: "INT",
      notnull: 0,
      dflt_value: null,
      pk: 0,
    },
    { cid: 4, name: "sql", type: "TEXT", notnull: 0, dflt_value: null, pk: 0 },
  ];
  t.deepEqual(actual, expectedValue);
});

inMemoryTest.both("simple pragma table_list", async (t) => {
  const db = t.context.db;
  let param = "sqlite_schema";
  let actual = db.pragma(`table_info(${param})`, { simple: true });
  let expectedValue = 0;
  t.deepEqual(actual, expectedValue);
});

inMemoryTest.onlySqlitePasses(
  "Statement shouldn't bind twice with bind()",
  async (t) => {
    const db = t.context.db;
    db.prepare("CREATE TABLE users (name TEXT, age INTEGER)").run();
    db.prepare("INSERT INTO users (name, age) VALUES (?, ?)").run("Alice", 42);
    let stmt = db.prepare("SELECT * FROM users WHERE name = ?").bind("Alice");

    let row = stmt.get();
    t.truthy(row.name);
    t.true(typeof row.age === "number");

    t.throws(
      () => {
        stmt.bind("Bob");
      },
      {
        instanceOf: TypeError,
        message:
          "The bind() method can only be invoked once per statement object",
      },
    );
  },
);

inMemoryTest.both(
  "Test pluck(): Rows should only have the values of the first column",
  async (t) => {
    const db = t.context.db;
    db.prepare("CREATE TABLE users (name TEXT, age INTEGER)").run();
    db.prepare("INSERT INTO users (name, age) VALUES (?, ?)").run("Alice", 42);
    db.prepare("INSERT INTO users (name, age) VALUES (?, ?)").run("Bob", 24);

    let stmt = db.prepare("SELECT * FROM users").pluck();

    for (const row of stmt.all()) {
      t.truthy(row);
      t.assert(typeof row === "string");
    }
  },
);

inMemoryTest.both(
  "Test raw(): Rows should be returned as arrays",
  async (t) => {
    const db = t.context.db;
    db.prepare("CREATE TABLE users (name TEXT, age INTEGER)").run();
    db.prepare("INSERT INTO users (name, age) VALUES (?, ?)").run("Alice", 42);
    db.prepare("INSERT INTO users (name, age) VALUES (?, ?)").run("Bob", 24);

    let stmt = db.prepare("SELECT * FROM users").raw();

    for (const row of stmt.all()) {
      t.true(Array.isArray(row));
      t.true(typeof row[0] === "string");
      t.true(typeof row[1] === "number");
    }

    stmt = db.prepare("SELECT * FROM users WHERE name = ?").raw();
    const row = stmt.get("Alice");
    t.true(Array.isArray(row));
    t.is(row.length, 2);
    t.is(row[0], "Alice");
    t.is(row[1], 42);

    const noRow = stmt.get("Charlie");
    t.is(noRow, undefined);

    stmt = db.prepare("SELECT * FROM users").raw();
    const rows = stmt.all();
    t.true(Array.isArray(rows));
    t.is(rows.length, 2);
    t.deepEqual(rows[0], ["Alice", 42]);
    t.deepEqual(rows[1], ["Bob", 24]);
  },
);

inMemoryTest.onlySqlitePasses(
  "Test expand(): Columns should be namespaced",
  async (t) => {
    const expandedResults = [
      {
        users: {
          name: "Alice",
          type: "premium",
        },
        addresses: {
          userName: "Alice",
          type: "home",
          street: "Alice's street",
        },
      },
      {
        users: {
          name: "Bob",
          type: "basic",
        },
        addresses: {
          userName: "Bob",
          type: "work",
          street: "Bob's street",
        },
      },
    ];

    let regularResults = [
      {
        name: "Alice",
        street: "Alice's street",
        type: "home",
        userName: "Alice",
      },
      {
        name: "Bob",
        street: "Bob's street",
        type: "work",
        userName: "Bob",
      },
    ];

    const db = t.context.db;
    db.prepare("CREATE TABLE users (name TEXT, type TEXT)").run();
    db.prepare(
      "CREATE TABLE addresses (userName TEXT, street TEXT, type TEXT)",
    ).run();
    db.prepare("INSERT INTO users (name, type) VALUES (?, ?)").run(
      "Alice",
      "premium",
    );
    db.prepare("INSERT INTO users (name, type) VALUES (?, ?)").run(
      "Bob",
      "basic",
    );
    db.prepare(
      "INSERT INTO addresses (userName, street, type) VALUES (?, ?, ?)",
    ).run("Alice", "Alice's street", "home");
    db.prepare(
      "INSERT INTO addresses (userName, street, type) VALUES (?, ?, ?)",
    ).run("Bob", "Bob's street", "work");

    let allRows = db
      .prepare(
        "SELECT * FROM users u JOIN addresses a ON (u.name = a.userName)",
      )
      .expand(true)
      .all();

    t.deepEqual(allRows, expandedResults);

    allRows = db
      .prepare(
        "SELECT * FROM users u JOIN addresses a ON (u.name = a.userName)",
      )
      .expand()
      .all();

    t.deepEqual(allRows, expandedResults);

    allRows = db
      .prepare(
        "SELECT * FROM users u JOIN addresses a ON (u.name = a.userName)",
      )
      .expand(false)
      .all();

    t.deepEqual(allRows, regularResults);
  },
);

inMemoryTest.both(
  "Presentation modes should be mutually exclusive",
  async (t) => {
    const db = t.context.db;
    db.prepare("CREATE TABLE users (name TEXT, age INTEGER)").run();
    db.prepare("INSERT INTO users (name, age) VALUES (?, ?)").run("Alice", 42);
    db.prepare("INSERT INTO users (name, age) VALUES (?, ?)").run("Bob", 24);

    // test raw()
    let stmt = db.prepare("SELECT * FROM users").pluck().raw();

    for (const row of stmt.all()) {
      t.true(Array.isArray(row));
      t.true(typeof row[0] === "string");
      t.true(typeof row[1] === "number");
    }

    stmt = db.prepare("SELECT * FROM users WHERE name = ?").raw();
    const row = stmt.get("Alice");
    t.true(Array.isArray(row));
    t.is(row.length, 2);
    t.is(row[0], "Alice");
    t.is(row[1], 42);

    const noRow = stmt.get("Charlie");
    t.is(noRow, undefined);

    stmt = db.prepare("SELECT * FROM users").raw();
    let rows = stmt.all();
    t.true(Array.isArray(rows));
    t.is(rows.length, 2);
    t.deepEqual(rows[0], ["Alice", 42]);
    t.deepEqual(rows[1], ["Bob", 24]);

    // test pluck()
    stmt = db.prepare("SELECT * FROM users").raw().pluck();

    for (const name of stmt.all()) {
      t.truthy(name);
      t.assert(typeof name === "string");
    }
  },
);

inMemoryTest.onlySqlitePasses(
  "Presentation mode 'expand' should be mutually exclusive",
  async (t) => {
    // this test can be appended to the previous one when 'expand' is implemented in Turso
    const db = t.context.db;
    db.prepare("CREATE TABLE users (name TEXT, age INTEGER)").run();
    db.prepare("INSERT INTO users (name, age) VALUES (?, ?)").run("Alice", 42);
    db.prepare("INSERT INTO users (name, age) VALUES (?, ?)").run("Bob", 24);

    let stmt = db.prepare("SELECT * FROM users").pluck().raw();

    // test expand()
    stmt = db.prepare("SELECT * FROM users").raw().pluck().expand();
    const rows = stmt.all();
    t.true(Array.isArray(rows));
    t.is(rows.length, 2);
    t.deepEqual(rows[0], { users: { name: "Alice", age: 42 } });
    t.deepEqual(rows[1], { users: { name: "Bob", age: 24 } });
  },
);

inMemoryTest.both(
  "Test exec(): Should correctly load multiple statements from file",
  async (t) => {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    const db = t.context.db;
    const file = fs.readFileSync(
      path.resolve(__dirname, "./artifacts/basic-test.sql"),
      "utf8",
    );
    db.exec(file);
    let rows = db.prepare("SELECT * FROM users").all();
    for (const row of rows) {
      t.truthy(row.name);
      t.true(typeof row.age === "number");
    }
  },
);

inMemoryTest.both(
  "Test Statement.database gets the database object",
  async (t) => {
    const db = t.context.db;
    let stmt = db.prepare("SELECT 1");
    t.is(stmt.database, db);
  },
);

inMemoryTest.both("Test Statement.source", async (t) => {
  const db = t.context.db;
  let sql = "CREATE TABLE t (id int)";
  let stmt = db.prepare(sql);
  t.is(stmt.source, sql);
});



================================================
FILE: bindings/javascript/__test__/dual-test.mjs
================================================
import avaTest from "ava";
import turso from "../wrapper.js";
import sqlite from "better-sqlite3";

class DualTest {

  #libs = { turso, sqlite };
  #beforeEaches = [];
  #pathFn;
  #options;

  constructor(path_opt, options = {}) {
    if (typeof path_opt === 'function') {
      this.#pathFn = path_opt;
    } else {
      this.#pathFn = () => path_opt ?? "hello.db";
    }
    this.#options = options;
  }

  beforeEach(fn) {
    this.#beforeEaches.push(fn);
  }

  only(name, impl, ...rest) {
    avaTest.serial.only('[TESTING TURSO] ' + name, this.#wrap('turso', impl), ...rest);
    avaTest.serial.only('[TESTING BETTER-SQLITE3] ' + name, this.#wrap('sqlite', impl), ...rest);
  }

  onlySqlitePasses(name, impl, ...rest) {
    avaTest.serial.failing('[TESTING TURSO] ' + name, this.#wrap('turso', impl), ...rest);
    avaTest.serial('[TESTING BETTER-SQLITE3] ' + name, this.#wrap('sqlite', impl), ...rest);
  }

  both(name, impl, ...rest) {
    avaTest.serial('[TESTING TURSO] ' + name, this.#wrap('turso', impl), ...rest);
    avaTest.serial('[TESTING BETTER-SQLITE3] ' + name, this.#wrap('sqlite', impl), ...rest);
  }

  skip(name, impl, ...rest) {
    avaTest.serial.skip('[TESTING TURSO] ' + name, this.#wrap('turso', impl), ...rest);
    avaTest.serial.skip('[TESTING BETTER-SQLITE3] ' + name, this.#wrap('sqlite', impl), ...rest);
  }

  async #runBeforeEach(t) {
    for (const beforeEach of this.#beforeEaches) {
      await beforeEach(t);
    }
  }

  #wrap(provider, fn) {
    return async (t, ...rest) => {
      const path = this.#pathFn();
      const Lib = this.#libs[provider];
      const db = this.#connect(Lib, path, this.#options)
      t.context = {
        ...t,
        connect: this.#curry(this.#connect)(Lib),
        db,
        errorType: Lib.SqliteError,
        path,
        provider,
      };

      t.teardown(() => db.close());
      await this.#runBeforeEach(t);
      await fn(t, ...rest);
    };
  }

  #connect(constructor, path, options) {
    return new constructor(path, options);
  }

  #curry(fn) {
    return (first) => (...rest) => fn(first, ...rest);
  }
}

export default DualTest;





================================================
FILE: bindings/javascript/__test__/sync.spec.mjs
================================================
import crypto from "crypto";
import fs from "fs";
import DualTest from "./dual-test.mjs";

const dualTest = new DualTest();

new DualTest(":memory:").both("Open in-memory database", async (t) => {
  const db = t.context.db;
  t.is(db.memory, true);
});

dualTest.beforeEach(async (t) => {
  const db = t.context.db;

  db.exec(`
      DROP TABLE IF EXISTS users;
      CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, email TEXT)
  `);
  db.exec(
    "INSERT INTO users (id, name, email) VALUES (1, 'Alice', 'alice@example.org')",
  );
  db.exec(
    "INSERT INTO users (id, name, email) VALUES (2, 'Bob', 'bob@example.com')",
  );
});

dualTest.onlySqlitePasses("Statement.prepare() error", async (t) => {
  const db = t.context.db;

  t.throws(
    () => {
      return db.prepare("SYNTAX ERROR");
    },
    {
      any: true,
      instanceOf: t.context.errorType,
      message: 'near "SYNTAX": syntax error',
    },
  );
});

dualTest.both("Statement.run() returning rows", async (t) => {
  const db = t.context.db;

  const stmt = db.prepare("SELECT 1");
  const info = stmt.run();
  t.is(info.changes, 0);
});

dualTest.both("Statement.run() [positional]", async (t) => {
  const db = t.context.db;

  const stmt = db.prepare("INSERT INTO users(name, email) VALUES (?, ?)");
  const info = stmt.run(["Carol", "carol@example.net"]);
  t.is(info.changes, 1);
  t.is(info.lastInsertRowid, 3);

  // Verify that the data is inserted
  const stmt2 = db.prepare("SELECT * FROM users WHERE id = 3");
  t.is(stmt2.get().name, "Carol");
  t.is(stmt2.get().email, "carol@example.net");
});

dualTest.both("Statement.run() [named]", async (t) => {
  const db = t.context.db;

  const stmt = db.prepare(
    "INSERT INTO users(name, email) VALUES (@name, @email);",
  );
  const info = stmt.run({ name: "Carol", email: "carol@example.net" });
  t.is(info.changes, 1);
  t.is(info.lastInsertRowid, 3);
});

dualTest.both("Statement.get() returns no rows", async (t) => {
  const db = t.context.db;

  const stmt = db.prepare("SELECT * FROM users WHERE id = 0");
  t.is(stmt.get(), undefined);
});

dualTest.both("Statement.get() [no parameters]", async (t) => {
  const db = t.context.db;

  var stmt = 0;

  stmt = db.prepare("SELECT * FROM users");
  t.is(stmt.get().name, "Alice");
  t.deepEqual(stmt.raw().get(), [1, "Alice", "alice@example.org"]);
});

dualTest.both("Statement.get() [positional]", async (t) => {
  const db = t.context.db;

  var stmt = 0;

  stmt = db.prepare("SELECT * FROM users WHERE id = ?");
  t.is(stmt.get(0), undefined);
  t.is(stmt.get([0]), undefined);
  t.is(stmt.get(1).name, "Alice");
  t.is(stmt.get(2).name, "Bob");

  stmt = db.prepare("SELECT * FROM users WHERE id = ?1");
  t.is(stmt.get({ 1: 0 }), undefined);
  t.is(stmt.get({ 1: 1 }).name, "Alice");
  t.is(stmt.get({ 1: 2 }).name, "Bob");
});

dualTest.both("Statement.get() [named]", async (t) => {
  const db = t.context.db;

  var stmt = undefined;

  stmt = db.prepare("SELECT :b, :a");
  t.deepEqual(stmt.raw().get({ a: "a", b: "b" }), ["b", "a"]);

  stmt = db.prepare("SELECT * FROM users WHERE id = :id");
  t.is(stmt.get({ id: 0 }), undefined);
  t.is(stmt.get({ id: 1 }).name, "Alice");
  t.is(stmt.get({ id: 2 }).name, "Bob");

  stmt = db.prepare("SELECT * FROM users WHERE id = @id");
  t.is(stmt.get({ id: 0 }), undefined);
  t.is(stmt.get({ id: 1 }).name, "Alice");
  t.is(stmt.get({ id: 2 }).name, "Bob");

  stmt = db.prepare("SELECT * FROM users WHERE id = $id");
  t.is(stmt.get({ id: 0 }), undefined);
  t.is(stmt.get({ id: 1 }).name, "Alice");
  t.is(stmt.get({ id: 2 }).name, "Bob");
});

dualTest.both("Statement.get() [raw]", async (t) => {
  const db = t.context.db;

  const stmt = db.prepare("SELECT * FROM users WHERE id = ?");
  t.deepEqual(stmt.raw().get(1), [1, "Alice", "alice@example.org"]);
});

dualTest.onlySqlitePasses("Statement.iterate() [empty]", async (t) => {
  const db = t.context.db;

  const stmt = db.prepare("SELECT * FROM users WHERE id = 0");
  t.is(stmt.iterate().next().done, true);
  t.is(stmt.iterate([]).next().done, true);
  t.is(stmt.iterate({}).next().done, true);
});

dualTest.onlySqlitePasses("Statement.iterate()", async (t) => {
  const db = t.context.db;

  const stmt = db.prepare("SELECT * FROM users");
  const expected = [1, 2];
  var idx = 0;
  for (const row of stmt.iterate()) {
    t.is(row.id, expected[idx++]);
  }
});

dualTest.both("Statement.all()", async (t) => {
  const db = t.context.db;

  const stmt = db.prepare("SELECT * FROM users");
  const expected = [
    { id: 1, name: "Alice", email: "alice@example.org" },
    { id: 2, name: "Bob", email: "bob@example.com" },
  ];
  t.deepEqual(stmt.all(), expected);
});

dualTest.both("Statement.all() [raw]", async (t) => {
  const db = t.context.db;

  const stmt = db.prepare("SELECT * FROM users");
  const expected = [
    [1, "Alice", "alice@example.org"],
    [2, "Bob", "bob@example.com"],
  ];
  t.deepEqual(stmt.raw().all(), expected);
});

dualTest.both("Statement.all() [pluck]", async (t) => {
  const db = t.context.db;

  const stmt = db.prepare("SELECT * FROM users");
  const expected = [1, 2];
  t.deepEqual(stmt.pluck().all(), expected);
});

dualTest.both(
  "Statement.raw() [passing false should disable raw mode]",
  async (t) => {
    const db = t.context.db;

    const stmt = db.prepare("SELECT * FROM users");
    const expected = [
      { id: 1, name: "Alice", email: "alice@example.org" },
      { id: 2, name: "Bob", email: "bob@example.com" },
    ];
    t.deepEqual(stmt.raw(false).all(), expected);
  },
);

dualTest.both(
  "Statement.pluck() [passing false should disable pluck mode]",
  async (t) => {
    const db = t.context.db;

    const stmt = db.prepare("SELECT * FROM users");
    const expected = [
      { id: 1, name: "Alice", email: "alice@example.org" },
      { id: 2, name: "Bob", email: "bob@example.com" },
    ];
    t.deepEqual(stmt.pluck(false).all(), expected);
  },
);

dualTest.onlySqlitePasses(
  "Statement.all() [default safe integers]",
  async (t) => {
    const db = t.context.db;
    db.defaultSafeIntegers();
    const stmt = db.prepare("SELECT * FROM users");
    const expected = [
      [1n, "Alice", "alice@example.org"],
      [2n, "Bob", "bob@example.com"],
    ];
    t.deepEqual(stmt.raw().all(), expected);
  },
);

dualTest.onlySqlitePasses(
  "Statement.all() [statement safe integers]",
  async (t) => {
    const db = t.context.db;
    const stmt = db.prepare("SELECT * FROM users");
    stmt.safeIntegers();
    const expected = [
      [1n, "Alice", "alice@example.org"],
      [2n, "Bob", "bob@example.com"],
    ];
    t.deepEqual(stmt.raw().all(), expected);
  },
);

dualTest.onlySqlitePasses("Statement.raw() [failure]", async (t) => {
  const db = t.context.db;
  const stmt = db.prepare(
    "INSERT INTO users (id, name, email) VALUES (?, ?, ?)",
  );
  await t.throws(
    () => {
      stmt.raw();
    },
    {
      message: "The raw() method is only for statements that return data",
    },
  );
});

dualTest.onlySqlitePasses(
  "Statement.run() with array bind parameter",
  async (t) => {
    const db = t.context.db;

    db.exec(`
      DROP TABLE IF EXISTS t;
      CREATE TABLE t (value BLOB);
  `);

    const array = [1, 2, 3];

    const insertStmt = db.prepare("INSERT INTO t (value) VALUES (?)");
    await t.throws(
      () => {
        insertStmt.run([array]);
      },
      {
        message:
          "SQLite3 can only bind numbers, strings, bigints, buffers, and null",
      },
    );
  },
);

dualTest.onlySqlitePasses(
  "Statement.run() with Float32Array bind parameter",
  async (t) => {
    const db = t.context.db;

    db.exec(`
      DROP TABLE IF EXISTS t;
      CREATE TABLE t (value BLOB);
  `);

    const array = new Float32Array([1, 2, 3]);

    const insertStmt = db.prepare("INSERT INTO t (value) VALUES (?)");
    insertStmt.run([array]);

    const selectStmt = db.prepare("SELECT value FROM t");
    t.deepEqual(selectStmt.raw().get()[0], Buffer.from(array.buffer));
  },
);

/// This test is not supported by better-sqlite3, but is supported by libsql.
/// Therefore, when implementing it in Turso, only enable the test for Turso.
dualTest.skip(
  "Statement.run() for vector feature with Float32Array bind parameter",
  async (t) => {
    const db = t.context.db;

    db.exec(`
    DROP TABLE IF EXISTS t;
    CREATE TABLE t (embedding FLOAT32(8));
    CREATE INDEX t_idx ON t ( libsql_vector_idx(embedding) );
  `);

    const insertStmt = db.prepare("INSERT INTO t VALUES (?)");
    insertStmt.run([new Float32Array([1, 1, 1, 1, 1, 1, 1, 1])]);
    insertStmt.run([new Float32Array([-1, -1, -1, -1, -1, -1, -1, -1])]);

    const selectStmt = db.prepare(
      "SELECT embedding FROM vector_top_k('t_idx', vector('[2,2,2,2,2,2,2,2]'), 1) n JOIN t ON n.rowid = t.rowid",
    );
    t.deepEqual(
      selectStmt.raw().get()[0],
      Buffer.from(new Float32Array([1, 1, 1, 1, 1, 1, 1, 1]).buffer),
    );

    // we need to explicitly delete this table because later when sqlite-based (not LibSQL) tests will delete table 't' they will leave 't_idx_shadow' table untouched
    db.exec(`DROP TABLE t`);
  },
);

dualTest.onlySqlitePasses("Statement.columns()", async (t) => {
  const db = t.context.db;

  var stmt = undefined;

  stmt = db.prepare("SELECT 1");
  t.deepEqual(stmt.columns(), [
    {
      column: null,
      database: null,
      name: "1",
      table: null,
      type: null,
    },
  ]);

  stmt = db.prepare("SELECT * FROM users WHERE id = ?");
  t.deepEqual(stmt.columns(), [
    {
      column: "id",
      database: "main",
      name: "id",
      table: "users",
      type: "INTEGER",
    },
    {
      column: "name",
      database: "main",
      name: "name",
      table: "users",
      type: "TEXT",
    },
    {
      column: "email",
      database: "main",
      name: "email",
      table: "users",
      type: "TEXT",
    },
  ]);
});

dualTest.onlySqlitePasses("Database.transaction()", async (t) => {
  const db = t.context.db;

  const insert = db.prepare(
    "INSERT INTO users(name, email) VALUES (:name, :email)",
  );

  const insertMany = db.transaction((users) => {
    t.is(db.inTransaction, true);
    for (const user of users) insert.run(user);
  });

  t.is(db.inTransaction, false);
  insertMany([
    { name: "Joey", email: "joey@example.org" },
    { name: "Sally", email: "sally@example.org" },
    { name: "Junior", email: "junior@example.org" },
  ]);
  t.is(db.inTransaction, false);

  const stmt = db.prepare("SELECT * FROM users WHERE id = ?");
  t.is(stmt.get(3).name, "Joey");
  t.is(stmt.get(4).name, "Sally");
  t.is(stmt.get(5).name, "Junior");
});

dualTest.onlySqlitePasses("Database.transaction().immediate()", async (t) => {
  const db = t.context.db;
  const insert = db.prepare(
    "INSERT INTO users(name, email) VALUES (:name, :email)",
  );
  const insertMany = db.transaction((users) => {
    t.is(db.inTransaction, true);
    for (const user of users) insert.run(user);
  });
  t.is(db.inTransaction, false);
  insertMany.immediate([
    { name: "Joey", email: "joey@example.org" },
    { name: "Sally", email: "sally@example.org" },
    { name: "Junior", email: "junior@example.org" },
  ]);
  t.is(db.inTransaction, false);
});

dualTest.onlySqlitePasses("values", async (t) => {
  const db = t.context.db;

  const stmt = db.prepare("SELECT ?").raw();
  t.deepEqual(stmt.get(1), [1]);
  t.deepEqual(stmt.get(Number.MIN_VALUE), [Number.MIN_VALUE]);
  t.deepEqual(stmt.get(Number.MAX_VALUE), [Number.MAX_VALUE]);
  t.deepEqual(stmt.get(Number.MAX_SAFE_INTEGER), [Number.MAX_SAFE_INTEGER]);
  t.deepEqual(stmt.get(9007199254740991n), [9007199254740991]);
});

dualTest.both("Database.pragma()", async (t) => {
  const db = t.context.db;
  db.pragma("cache_size = 2000");
  t.deepEqual(db.pragma("cache_size"), [{ cache_size: 2000 }]);
});

dualTest.both("errors", async (t) => {
  const db = t.context.db;

  const syntaxError = await t.throws(
    () => {
      db.exec("SYNTAX ERROR");
    },
    {
      any: true,
      instanceOf: t.context.errorType,
      message: /near "SYNTAX": syntax error/,
      code: "SQLITE_ERROR",
    },
  );
  const noTableError = await t.throws(
    () => {
      db.exec("SELECT * FROM missing_table");
    },
    {
      any: true,
      instanceOf: t.context.errorType,
      message:
        /(Parse error: Table missing_table not found|no such table: missing_table)/,
      code: "SQLITE_ERROR",
    },
  );

  if (t.context.provider === "libsql") {
    t.is(noTableError.rawCode, 1);
    t.is(syntaxError.rawCode, 1);
  }
});

dualTest.onlySqlitePasses("Database.prepare() after close()", async (t) => {
  const db = t.context.db;
  db.close();
  t.throws(
    () => {
      db.prepare("SELECT 1");
    },
    {
      instanceOf: TypeError,
      message: "The database connection is not open",
    },
  );
});

dualTest.onlySqlitePasses("Database.exec() after close()", async (t) => {
  const db = t.context.db;
  db.close();
  t.throws(
    () => {
      db.exec("SELECT 1");
    },
    {
      instanceOf: TypeError,
      message: "The database connection is not open",
    },
  );
});

/// Generate a unique database filename
const genDatabaseFilename = () => {
  return `test-${crypto.randomBytes(8).toString("hex")}.db`;
};

new DualTest(genDatabaseFilename).onlySqlitePasses(
  "Timeout option",
  async (t) => {
    t.teardown(() => fs.unlinkSync(t.context.path));

    const timeout = 1000;
    const { db: conn1 } = t.context;
    conn1.exec("CREATE TABLE t(x)");
    conn1.exec("BEGIN IMMEDIATE");
    conn1.exec("INSERT INTO t VALUES (1)");
    const options = { timeout };
    const conn2 = t.context.connect(t.context.path, options);
    const start = Date.now();
    try {
      conn2.exec("INSERT INTO t VALUES (1)");
    } catch (e) {
      t.is(e.code, "SQLITE_BUSY");
      const end = Date.now();
      const elapsed = end - start;
      // Allow some tolerance for the timeout.
      t.is(elapsed > timeout / 2, true);
    }
    conn1.close();
    conn2.close();
  },
);



================================================
FILE: bindings/javascript/__test__/artifacts/basic-test.sql
================================================
CREATE TABLE users (name TEXT, age INTEGER);
INSERT INTO users (name, age) VALUES ('Bob', 24); 
INSERT INTO users (name, age) VALUES ('Alice', 42);


================================================
FILE: bindings/javascript/docs/API.md
================================================
# class Database

The `Database` class represents a connection that can prepare and execute SQL statements.

## Methods

### new Database(path, [options]) ⇒ Database

Creates a new database connection.

| Param   | Type                | Description               |
| ------- | ------------------- | ------------------------- |
| path    | <code>string</code> | Path to the database file |
| options | <code>object</code> | Options.                  |

The `path` parameter points to the SQLite database file to open. If the file pointed to by `path` does not exists, it will be created.
To open an in-memory database, please pass `:memory:` as the `path` parameter.

The function returns a `Database` object.

### prepare(sql) ⇒ Statement

Prepares a SQL statement for execution.

| Param | Type                | Description                          |
| ----- | ------------------- | ------------------------------------ |
| sql   | <code>string</code> | The SQL statement string to prepare. |

The function returns a `Statement` object.

### transaction(function) ⇒ function

Returns a function that runs the given function in a transaction.

| Param    | Type                  | Description                           |
| -------- | --------------------- | ------------------------------------- |
| function | <code>function</code> | The function to run in a transaction. |

### pragma(string, [options]) ⇒ results

Executes the given PRAGMA and returns its results.

| Param    | Type                  | Description           |
| -------- | --------------------- | ----------------------|
| source   | <code>string</code>   | Pragma to be executed |
| options  | <code>object</code>   | Options.              |

Most PRAGMA return a single value, the `simple: boolean` option is provided to return the first column of the first row.

```js
db.pragma('cache_size = 32000');
console.log(db.pragma('cache_size', { simple: true })); // => 32000
```

### backup(destination, [options]) ⇒ promise

This function is currently not supported.

### serialize([options]) ⇒ Buffer

This function is currently not supported.

### function(name, [options], function) ⇒ this

This function is currently not supported.

### aggregate(name, options) ⇒ this

This function is currently not supported.

### table(name, definition) ⇒ this

This function is currently not supported.

### loadExtension(path, [entryPoint]) ⇒ this

Loads a SQLite3 extension.

| Param | Type                | Description                             |
| ----- | ------------------- | --------------------------------------- |
| path  | <code>string</code> | The path to the extension to be loaded. |

### exec(sql) ⇒ this

Executes a SQL statement.

| Param | Type                | Description                          |
| ----- | ------------------- | ------------------------------------ |
| sql   | <code>string</code> | The SQL statement string to execute. |

This can execute strings that contain multiple SQL statements.

### interrupt() ⇒ this

Cancel ongoing operations and make them return at earliest opportunity.

**Note:** This is an extension in libSQL and not available in `better-sqlite3`.

This function is currently not supported.

### close() ⇒ this

Closes the database connection.

# class Statement

## Methods

### run([...bindParameters]) ⇒ object

Executes the SQL statement and (currently) returns an array with results.

**Note:** It should return an info object.

| Param          | Type                          | Description                                      |
| -------------- | ----------------------------- | ------------------------------------------------ |
| bindParameters | <code>array of objects</code> | The bind parameters for executing the statement. |

The returned info object contains two properties: `changes` that describes the number of modified rows and `info.lastInsertRowid` that represents the `rowid` of the last inserted row.

This function is currently not supported.

### get([...bindParameters]) ⇒ row

Executes the SQL statement and returns the first row.

| Param          | Type                          | Description                                      |
| -------------- | ----------------------------- | ------------------------------------------------ |
| bindParameters | <code>array of objects</code> | The bind parameters for executing the statement. |

### all([...bindParameters]) ⇒ array of rows

Executes the SQL statement and returns an array of the resulting rows.

| Param          | Type                          | Description                                      |
| -------------- | ----------------------------- | ------------------------------------------------ |
| bindParameters | <code>array of objects</code> | The bind parameters for executing the statement. |

### iterate([...bindParameters]) ⇒ iterator

Executes the SQL statement and returns an iterator to the resulting rows.

| Param          | Type                          | Description                                      |
| -------------- | ----------------------------- | ------------------------------------------------ |
| bindParameters | <code>array of objects</code> | The bind parameters for executing the statement. |

### pluck([toggleState]) ⇒ this

Makes the prepared statement only return the value of the first column of any rows that it retrieves.

| Param     | Type                 | Description                                                                            |
| --------- | -------------------- | -------------------------------------------------------------------------------------- |
| pluckMode | <code>boolean</code> | Enable of disable pluck mode. If you don't pass the paramenter, pluck mode is enabled. |

```js
stmt.pluck(); // plucking ON
stmt.pluck(true); // plucking ON
stmt.pluck(false); // plucking OFF
```

> NOTE: When plucking is turned on, raw mode is turned off (they are mutually exclusive options).

### expand([toggleState]) ⇒ this

This function is currently not supported.

### raw([rawMode]) ⇒ this

Makes the prepared statement return rows as arrays instead of objects.

| Param   | Type                 | Description                                                                       |
| ------- | -------------------- | --------------------------------------------------------------------------------- |
| rawMode | <code>boolean</code> | Enable or disable raw mode. If you don't pass the parameter, raw mode is enabled. |

This function enables or disables raw mode. Prepared statements return objects by default, but if raw mode is enabled, the functions return arrays instead.

```js
stmt.raw(); // raw mode ON
stmt.raw(true); // raw mode ON
stmt.raw(false); // raw mode OFF
```

> NOTE: When raw mode is turned on, plucking is turned off (they are mutually exclusive options).

### columns() ⇒ array of objects

Returns the columns in the result set returned by this prepared statement.

This function is currently not supported.

### bind([...bindParameters]) ⇒ this

| Param          | Type                          | Description                                      |
| -------------- | ----------------------------- | ------------------------------------------------ |
| bindParameters | <code>array of objects</code> | The bind parameters for executing the statement. |

Binds **permanently** the given parameters to the statement. After a statement's parameters are bound this way, you may no longer provide it with execution-specific (temporary) bound parameters.




================================================
FILE: bindings/javascript/docs/CONTRIBUTING.md
================================================
# Contributing

So you want to contribute to Limbo's binding for the ~second~ best language in the world? Awesome.

First things first you'll need to install [napi-rs](https://napi.rs/), follow the instructions [here](https://napi.rs/docs/introduction/getting-started) although is highly recommended to use `yarn` with:

```sh
yarn global add @napi-rs/cli
```

Run `yarn build` to build our napi project and run `yarn test` to run our test suite, if nothing breaks you're ready to start!

## API

You can check the API docs [here](./API.md), it aims to be fully compatible with [better-sqlite](https://github.com/WiseLibs/better-sqlite3/) and borrows some things from [libsql](https://github.com/tursodatabase/libsql-js). So if you find some incompability in behaviour and/or lack of functions/attributes, that's an issue and you should work on it for a great good :)

## Code Structure

The Rust code for the bind is on [lib.rs](../src/lib.rs). It's exposed to JS users through [wrapper](../wrapper.js), where you can
use some JS' ~weirdness~ facilities, for instance, since Rust doesn't have variadic functions the wrapper enables us to "normalize" `bindParameters` into an array.

All tests should be within the [__test__](../__test__/) folder.

# Before open a PR

Please be assured that:

- Your fix/feature has a test checking the new behaviour;
- Your Rust code is formatted with `cargo fmt`;
- Your JavaScript code is formatted with `tsserver` (VSCode's default);
- If applicable, update the [API docs](./API.md) to match the current implementation;




================================================
FILE: bindings/javascript/examples/drizzle/example.js
================================================
import { drizzle } from "drizzle-orm/better-sqlite3";
import { sql } from "drizzle-orm";
import Database from '@tursodatabase/turso';

const sqlite = new Database('sqlite.db');
const db = drizzle({ client: sqlite });
const result = await db.all(sql`select 1`);
console.log(result);



================================================
FILE: bindings/javascript/examples/drizzle/package.json
================================================
{
  "name": "drizzle",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@tursodatabase/turso": "../..",
    "better-sqlite3": "^12.2.0",
    "drizzle-orm": "^0.44.3"
  }
}



================================================
FILE: bindings/javascript/npm/darwin-universal/README.md
================================================
# `limbo-darwin-universal`

This is the **universal-apple-darwin** binary for `limbo`



================================================
FILE: bindings/javascript/npm/darwin-universal/package.json
================================================
{
  "name": "@tursodatabase/turso-darwin-universal",
  "version": "0.1.3-pre.5",
  "repository": {
    "type": "git",
    "url": "https://github.com/tursodatabase/turso"
  },
  "os": [
    "darwin"
  ],
  "main": "turso.darwin-universal.node",
  "files": [
    "turso.darwin-universal.node"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  }
}


================================================
FILE: bindings/javascript/npm/linux-x64-gnu/README.md
================================================
# `limbo-linux-x64-gnu`

This is the **x86_64-unknown-linux-gnu** binary for `limbo`



================================================
FILE: bindings/javascript/npm/linux-x64-gnu/package.json
================================================
{
  "name": "@tursodatabase/turso-linux-x64-gnu",
  "version": "0.1.3-pre.5",
  "repository": {
    "type": "git",
    "url": "https://github.com/tursodatabase/turso"
  },
  "os": [
    "linux"
  ],
  "cpu": [
    "x64"
  ],
  "main": "turso.linux-x64-gnu.node",
  "files": [
    "turso.linux-x64-gnu.node"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  },
  "libc": [
    "glibc"
  ]
}


================================================
FILE: bindings/javascript/npm/win32-x64-msvc/README.md
================================================
# `turso-win32-x64-msvc`

This is the **x86_64-pc-windows-msvc** binary for `@tursodatabase/turso`



================================================
FILE: bindings/javascript/npm/win32-x64-msvc/package.json
================================================
{
  "name": "@tursodatabase/turso-win32-x64-msvc",
  "version": "0.1.3-pre.5",
  "repository": {
    "type": "git",
    "url": "https://github.com/tursodatabase/turso"
  },
  "os": [
    "win32"
  ],
  "cpu": [
    "x64"
  ],
  "main": "turso.win32-x64-msvc.node",
  "files": [
    "turso.win32-x64-msvc.node"
  ],
  "license": "MIT",
  "engines": {
    "node": ">= 10"
  }
}


================================================
FILE: bindings/javascript/src/lib.rs
================================================
#![deny(clippy::all)]

use std::cell::{RefCell, RefMut};
use std::num::{NonZero, NonZeroUsize};

use std::rc::Rc;
use std::sync::Arc;

use napi::bindgen_prelude::{JsObjectValue, Null, Object, ToNapiValue};
use napi::{bindgen_prelude::ObjectFinalize, Env, JsValue, Unknown};
use napi_derive::napi;
use turso_core::{LimboError, StepResult};

#[derive(Default)]
#[napi(object)]
pub struct OpenDatabaseOptions {
    pub readonly: Option<bool>,
    pub file_must_exist: Option<bool>,
    pub timeout: Option<u32>,
    // verbose => Callback,
}

impl OpenDatabaseOptions {
    fn readonly(&self) -> bool {
        self.readonly.unwrap_or(false)
    }
}

#[napi(object)]
pub struct PragmaOptions {
    pub simple: bool,
}

#[napi(object)]
pub struct RunResult {
    pub changes: i64,
    pub last_insert_rowid: i64,
}

#[napi(custom_finalize)]
#[derive(Clone)]
pub struct Database {
    #[napi(writable = false)]
    pub memory: bool,

    #[napi(writable = false)]
    pub readonly: bool,
    // #[napi(writable = false)]
    // pub in_transaction: bool,
    #[napi(writable = false)]
    pub open: bool,
    #[napi(writable = false)]
    pub name: String,
    _db: Arc<turso_core::Database>,
    conn: Arc<turso_core::Connection>,
    _io: Arc<dyn turso_core::IO>,
}

impl ObjectFinalize for Database {
    // TODO: check if something more is required
    fn finalize(self, _env: Env) -> napi::Result<()> {
        self.conn.close().map_err(into_napi_error)?;
        Ok(())
    }
}

#[napi]
impl Database {
    #[napi(constructor)]
    pub fn new(path: String, options: Option<OpenDatabaseOptions>) -> napi::Result<Self, String> {
        let memory = path == ":memory:";
        let io: Arc<dyn turso_core::IO> = if memory {
            Arc::new(turso_core::MemoryIO::new())
        } else {
            Arc::new(turso_core::PlatformIO::new().map_err(into_napi_sqlite_error)?)
        };
        let opts = options.unwrap_or_default();
        let flag = if opts.readonly() {
            turso_core::OpenFlags::ReadOnly
        } else {
            turso_core::OpenFlags::Create
        };
        let file = io
            .open_file(&path, flag, false)
            .map_err(|err| into_napi_error_with_message("SQLITE_CANTOPEN".to_owned(), err))?;

        let db_file = Arc::new(DatabaseFile::new(file));
        let db = turso_core::Database::open(io.clone(), &path, db_file, false, false)
            .map_err(into_napi_sqlite_error)?;
        let conn = db.connect().map_err(into_napi_sqlite_error)?;

        Ok(Self {
            readonly: opts.readonly(),
            memory,
            _db: db,
            conn,
            open: true,
            name: path,
            _io: io,
        })
    }

    #[napi]
    pub fn prepare(&self, sql: String) -> napi::Result<Statement> {
        let stmt = self.conn.prepare(&sql).map_err(into_napi_error)?;
        Ok(Statement::new(RefCell::new(stmt), self.clone(), sql))
    }

    #[napi]
    pub fn pragma<'env>(
        &self,
        env: &'env Env,
        pragma_name: String,
        options: Option<PragmaOptions>,
    ) -> napi::Result<Unknown<'env>> {
        let sql = format!("PRAGMA {pragma_name}");
        let stmt = self.prepare(sql)?;
        match options {
            Some(PragmaOptions { simple: true, .. }) => {
                let mut stmt = stmt.inner.borrow_mut();
                loop {
                    match stmt.step().map_err(into_napi_error)? {
                        turso_core::StepResult::Row => {
                            let row: Vec<_> = stmt.row().unwrap().get_values().cloned().collect();
                            return to_js_value(env, row[0].clone());
                        }
                        turso_core::StepResult::Done => {
                            return ToNapiValue::into_unknown((), env);
                        }
                        turso_core::StepResult::IO => {
                            stmt.run_once().map_err(into_napi_error)?;
                            continue;
                        }
                        step @ turso_core::StepResult::Interrupt
                        | step @ turso_core::StepResult::Busy => {
                            return Err(napi::Error::new(
                                napi::Status::GenericFailure,
                                format!("{step:?}"),
                            ))
                        }
                    }
                }
            }
            _ => Ok(stmt.run_internal(env, None)?),
        }
    }

    #[napi]
    pub fn backup(&self) {
        todo!()
    }

    #[napi]
    pub fn serialize(&self) {
        todo!()
    }

    #[napi]
    pub fn function(&self) {
        todo!()
    }

    #[napi]
    pub fn aggregate(&self) {
        todo!()
    }

    #[napi]
    pub fn table(&self) {
        todo!()
    }

    #[napi]
    pub fn load_extension(&self, path: String) -> napi::Result<()> {
        let ext_path = turso_core::resolve_ext_path(path.as_str()).map_err(into_napi_error)?;
        self.conn
            .load_extension(ext_path)
            .map_err(into_napi_error)?;
        Ok(())
    }

    #[napi]
    pub fn exec(&self, sql: String) -> napi::Result<(), String> {
        let query_runner = self.conn.query_runner(sql.as_bytes());

        // Since exec doesn't return any values, we can just iterate over the results
        for output in query_runner {
            match output {
                Ok(Some(mut stmt)) => loop {
                    match stmt.step() {
                        Ok(StepResult::Row) => continue,
                        Ok(StepResult::IO) => stmt.run_once().map_err(into_napi_sqlite_error)?,
                        Ok(StepResult::Done) => break,
                        Ok(StepResult::Interrupt | StepResult::Busy) => {
                            return Err(napi::Error::new(
                                "SQLITE_ERROR".to_owned(),
                                "Statement execution interrupted or busy".to_string(),
                            ));
                        }
                        Err(err) => {
                            return Err(napi::Error::new(
                                "SQLITE_ERROR".to_owned(),
                                format!("Error executing SQL: {err}"),
                            ));
                        }
                    }
                },
                Ok(None) => continue,
                Err(err) => {
                    return Err(napi::Error::new(
                        "SQLITE_ERROR".to_owned(),
                        format!("Error executing SQL: {err}"),
                    ));
                }
            }
        }
        Ok(())
    }

    #[napi]
    pub fn close(&mut self) -> napi::Result<()> {
        if self.open {
            self.conn.close().map_err(into_napi_error)?;
            self.open = false;
        }
        Ok(())
    }
}

#[derive(Debug, Clone)]
enum PresentationMode {
    Raw,
    Pluck,
    None,
}

#[napi]
#[derive(Clone)]
pub struct Statement {
    // TODO: implement each property when core supports it
    // #[napi(able = false)]
    // pub reader: bool,
    // #[napi(writable = false)]
    // pub readonly: bool,
    // #[napi(writable = false)]
    // pub busy: bool,
    #[napi(writable = false)]
    pub source: String,

    database: Database,
    presentation_mode: PresentationMode,
    binded: bool,
    inner: Rc<RefCell<turso_core::Statement>>,
}

#[napi]
impl Statement {
    pub fn new(inner: RefCell<turso_core::Statement>, database: Database, source: String) -> Self {
        Self {
            inner: Rc::new(inner),
            database,
            source,
            presentation_mode: PresentationMode::None,
            binded: false,
        }
    }

    #[napi]
    pub fn get<'env>(
        &self,
        env: &'env Env,
        args: Option<Vec<Unknown>>,
    ) -> napi::Result<Unknown<'env>> {
        let mut stmt = self.check_and_bind(env, args)?;

        loop {
            let step = stmt.step().map_err(into_napi_error)?;
            match step {
                turso_core::StepResult::Row => {
                    let row = stmt.row().unwrap();

                    match self.presentation_mode {
                        PresentationMode::Raw => {
                            let mut raw_obj = env.create_array(row.len() as u32)?;
                            for (idx, value) in row.get_values().enumerate() {
                                let js_value = to_js_value(env, value.clone());

                                raw_obj.set(idx as u32, js_value)?;
                            }
                            return Ok(raw_obj.coerce_to_object()?.to_unknown());
                        }
                        PresentationMode::Pluck => {
                            let (_, value) =
                                row.get_values().enumerate().next().ok_or(napi::Error::new(
                                    napi::Status::GenericFailure,
                                    "Pluck mode requires at least one column in the result",
                                ))?;

                            let result = to_js_value(env, value.clone())?;
                            return ToNapiValue::into_unknown(result, env);
                        }
                        PresentationMode::None => {
                            let mut obj = Object::new(env)?;

                            for (idx, value) in row.get_values().enumerate() {
                                let key = stmt.get_column_name(idx);
                                let js_value = to_js_value(env, value.clone());

                                obj.set_named_property(&key, js_value)?;
                            }

                            return Ok(obj.to_unknown());
                        }
                    }
                }
                turso_core::StepResult::Done => return ToNapiValue::into_unknown((), env),
                turso_core::StepResult::IO => {
                    stmt.run_once().map_err(into_napi_error)?;
                    continue;
                }
                turso_core::StepResult::Interrupt | turso_core::StepResult::Busy => {
                    return Err(napi::Error::new(
                        napi::Status::GenericFailure,
                        format!("{step:?}"),
                    ))
                }
            }
        }
    }

    #[napi]
    pub fn run(&self, env: Env, args: Option<Vec<Unknown>>) -> napi::Result<RunResult> {
        self.run_and_build_info_object(|| self.run_internal(&env, args))
    }

    fn run_internal<'env>(
        &self,
        env: &'env Env,
        args: Option<Vec<Unknown>>,
    ) -> napi::Result<Unknown<'env>> {
        let stmt = self.check_and_bind(env, args)?;

        self.internal_all(env, stmt)
    }

    fn run_and_build_info_object<T, E>(
        &self,
        query_fn: impl FnOnce() -> Result<T, E>,
    ) -> Result<RunResult, E> {
        let total_changes_before = self.database.conn.total_changes();

        query_fn()?;

        let last_insert_rowid = self.database.conn.last_insert_rowid();
        let changes = if self.database.conn.total_changes() == total_changes_before {
            0
        } else {
            self.database.conn.changes()
        };

        Ok(RunResult {
            changes,
            last_insert_rowid,
        })
    }

    #[napi]
    pub fn all<'env>(
        &self,
        env: &'env Env,
        args: Option<Vec<Unknown>>,
    ) -> napi::Result<Unknown<'env>> {
        let stmt = self.check_and_bind(env, args)?;

        self.internal_all(env, stmt)
    }

    fn internal_all<'env>(
        &self,
        env: &'env Env,
        mut stmt: RefMut<'_, turso_core::Statement>,
    ) -> napi::Result<Unknown<'env>> {
        let mut results = env.create_array(1)?;
        let mut index = 0;
        loop {
            match stmt.step().map_err(into_napi_error)? {
                turso_core::StepResult::Row => {
                    let row = stmt.row().unwrap();

                    match self.presentation_mode {
                        PresentationMode::Raw => {
                            let mut raw_array = env.create_array(row.len() as u32)?;
                            for (idx, value) in row.get_values().enumerate() {
                                let js_value = to_js_value(env, value.clone())?;
                                raw_array.set(idx as u32, js_value)?;
                            }
                            results.set_element(index, raw_array.coerce_to_object()?)?;
                            index += 1;
                            continue;
                        }
                        PresentationMode::Pluck => {
                            let (_, value) =
                                row.get_values().enumerate().next().ok_or(napi::Error::new(
                                    napi::Status::GenericFailure,
                                    "Pluck mode requires at least one column in the result",
                                ))?;
                            let js_value = to_js_value(env, value.clone())?;
                            results.set_element(index, js_value)?;
                            index += 1;
                            continue;
                        }
                        PresentationMode::None => {
                            let mut obj = Object::new(env)?;
                            for (idx, value) in row.get_values().enumerate() {
                                let key = stmt.get_column_name(idx);
                                let js_value = to_js_value(env, value.clone());
                                obj.set_named_property(&key, js_value)?;
                            }
                            results.set_element(index, obj)?;
                            index += 1;
                        }
                    }
                }
                turso_core::StepResult::Done => {
                    break;
                }
                turso_core::StepResult::IO => {
                    stmt.run_once().map_err(into_napi_error)?;
                }
                turso_core::StepResult::Interrupt | turso_core::StepResult::Busy => {
                    return Err(napi::Error::new(
                        napi::Status::GenericFailure,
                        format!("{:?}", stmt.step()),
                    ));
                }
            }
        }

        Ok(results.to_unknown())
    }

    #[napi]
    pub fn pluck(&mut self, pluck: Option<bool>) {
        self.presentation_mode = match pluck {
            Some(false) => PresentationMode::None,
            _ => PresentationMode::Pluck,
        };
    }

    #[napi]
    pub fn expand() {
        todo!()
    }

    #[napi]
    pub fn raw(&mut self, raw: Option<bool>) {
        self.presentation_mode = match raw {
            Some(false) => PresentationMode::None,
            _ => PresentationMode::Raw,
        };
    }

    #[napi]
    pub fn columns() {
        todo!()
    }

    #[napi]
    pub fn bind(&mut self, env: Env, args: Option<Vec<Unknown>>) -> napi::Result<Self, String> {
        self.check_and_bind(&env, args)
            .map_err(with_sqlite_error_message)?;
        self.binded = true;

        Ok(self.clone())
    }

    /// Check if the Statement is already binded by the `bind()` method
    /// and bind values to variables.
    fn check_and_bind(
        &self,
        env: &Env,
        args: Option<Vec<Unknown>>,
    ) -> napi::Result<RefMut<'_, turso_core::Statement>> {
        let mut stmt = self.inner.borrow_mut();
        stmt.reset();
        if let Some(args) = args {
            if self.binded {
                let err = napi::Error::new(
                    into_convertible_type_error_message("TypeError"),
                    "The bind() method can only be invoked once per statement object",
                );
                unsafe {
                    napi::JsTypeError::from(err).throw_into(env.raw());
                }

                return Err(napi::Error::from_status(napi::Status::PendingException));
            }

            if args.len() == 1 {
                if matches!(args[0].get_type()?, napi::ValueType::Object) {
                    let obj: Object = args.into_iter().next().unwrap().coerce_to_object()?;

                    if obj.is_array()? {
                        bind_positional_param_array(&mut stmt, &obj)?;
                    } else {
                        bind_host_params(&mut stmt, &obj)?;
                    }
                } else {
                    bind_single_param(&mut stmt, args.into_iter().next().unwrap())?;
                }
            } else {
                bind_positional_params(&mut stmt, args)?;
            }
        }

        Ok(stmt)
    }
}

fn bind_positional_params(
    stmt: &mut RefMut<'_, turso_core::Statement>,
    args: Vec<Unknown>,
) -> Result<(), napi::Error> {
    for (i, elem) in args.into_iter().enumerate() {
        let value = from_js_value(elem)?;
        stmt.bind_at(NonZeroUsize::new(i + 1).unwrap(), value);
    }
    Ok(())
}

fn bind_host_params(
    stmt: &mut RefMut<'_, turso_core::Statement>,
    obj: &Object,
) -> Result<(), napi::Error> {
    if first_key_is_number(obj) {
        bind_numbered_params(stmt, obj)?;
    } else {
        bind_named_params(stmt, obj)?;
    }

    Ok(())
}

fn first_key_is_number(obj: &Object) -> bool {
    Object::keys(obj)
        .iter()
        .flatten()
        .filter(|key| matches!(obj.has_own_property(key), Ok(result) if result))
        .take(1)
        .any(|key| str::parse::<u32>(key).is_ok())
}

fn bind_numbered_params(
    stmt: &mut RefMut<'_, turso_core::Statement>,
    obj: &Object,
) -> Result<(), napi::Error> {
    for key in Object::keys(obj)?.iter() {
        let Ok(param_idx) = str::parse::<u32>(key) else {
            return Err(napi::Error::new(
                napi::Status::GenericFailure,
                "cannot mix numbers and strings",
            ));
        };
        let Some(non_zero) = NonZero::new(param_idx as usize) else {
            return Err(napi::Error::new(
                napi::Status::GenericFailure,
                "numbered parameters cannot be lower than 1",
            ));
        };

        stmt.bind_at(non_zero, from_js_value(obj.get_named_property(key)?)?);
    }
    Ok(())
}

fn bind_named_params(
    stmt: &mut RefMut<'_, turso_core::Statement>,
    obj: &Object,
) -> Result<(), napi::Error> {
    for idx in 1..stmt.parameters_count() + 1 {
        let non_zero_idx = NonZero::new(idx).unwrap();

        let param = stmt.parameters().name(non_zero_idx);
        let Some(name) = param else {
            return Err(napi::Error::from_reason(format!(
                "could not find named parameter with index {idx}"
            )));
        };

        let value = obj.get_named_property::<napi::Unknown>(&name[1..])?;
        stmt.bind_at(non_zero_idx, from_js_value(value)?);
    }

    Ok(())
}

fn bind_positional_param_array(
    stmt: &mut RefMut<'_, turso_core::Statement>,
    obj: &Object,
) -> Result<(), napi::Error> {
    assert!(obj.is_array()?, "bind_array can only be called with arrays");

    for idx in 1..obj.get_array_length()? {
        stmt.bind_at(
            NonZero::new(idx as usize).unwrap(),
            from_js_value(obj.get_element(idx)?)?,
        );
    }

    Ok(())
}

fn bind_single_param(
    stmt: &mut RefMut<'_, turso_core::Statement>,
    obj: napi::Unknown,
) -> Result<(), napi::Error> {
    stmt.bind_at(NonZero::new(1).unwrap(), from_js_value(obj)?);
    Ok(())
}

fn to_js_value<'a>(env: &'a napi::Env, value: turso_core::Value) -> napi::Result<Unknown<'a>> {
    match value {
        turso_core::Value::Null => ToNapiValue::into_unknown(Null, env),
        turso_core::Value::Integer(i) => ToNapiValue::into_unknown(i, env),
        turso_core::Value::Float(f) => ToNapiValue::into_unknown(f, env),
        turso_core::Value::Text(s) => ToNapiValue::into_unknown(s.as_str(), env),
        turso_core::Value::Blob(b) => ToNapiValue::into_unknown(b, env),
    }
}

fn from_js_value(value: Unknown<'_>) -> napi::Result<turso_core::Value> {
    match value.get_type()? {
        napi::ValueType::Undefined | napi::ValueType::Null | napi::ValueType::Unknown => {
            Ok(turso_core::Value::Null)
        }
        napi::ValueType::Boolean => {
            let b = value.coerce_to_bool()?;
            Ok(turso_core::Value::Integer(b as i64))
        }
        napi::ValueType::Number => {
            let num = value.coerce_to_number()?.get_double()?;
            if num.fract() == 0.0 {
                Ok(turso_core::Value::Integer(num as i64))
            } else {
                Ok(turso_core::Value::Float(num))
            }
        }
        napi::ValueType::String => {
            let s = value.coerce_to_string()?;
            Ok(turso_core::Value::Text(s.into_utf8()?.as_str()?.into()))
        }
        napi::ValueType::Symbol
        | napi::ValueType::Object
        | napi::ValueType::Function
        | napi::ValueType::External => Err(napi::Error::new(
            napi::Status::GenericFailure,
            "Unsupported type",
        )),
    }
}

struct DatabaseFile {
    file: Arc<dyn turso_core::File>,
}

unsafe impl Send for DatabaseFile {}
unsafe impl Sync for DatabaseFile {}

impl DatabaseFile {
    pub fn new(file: Arc<dyn turso_core::File>) -> Self {
        Self { file }
    }
}

impl turso_core::DatabaseStorage for DatabaseFile {
    fn read_page(&self, page_idx: usize, c: turso_core::Completion) -> turso_core::Result<()> {
        let r = match c.completion_type {
            turso_core::CompletionType::Read(ref r) => r,
            _ => unreachable!(),
        };
        let size = r.buf().len();
        assert!(page_idx > 0);
        if !(512..=65536).contains(&size) || size & (size - 1) != 0 {
            return Err(turso_core::LimboError::NotADB);
        }
        let pos = (page_idx - 1) * size;
        self.file.pread(pos, c.into())?;
        Ok(())
    }

    fn write_page(
        &self,
        page_idx: usize,
        buffer: Arc<std::cell::RefCell<turso_core::Buffer>>,
        c: turso_core::Completion,
    ) -> turso_core::Result<()> {
        let size = buffer.borrow().len();
        let pos = (page_idx - 1) * size;
        self.file.pwrite(pos, buffer, c.into())?;
        Ok(())
    }

    fn sync(&self, c: turso_core::Completion) -> turso_core::Result<()> {
        let _ = self.file.sync(c.into())?;
        Ok(())
    }

    fn size(&self) -> turso_core::Result<u64> {
        self.file.size()
    }
}

#[inline]
fn into_napi_error(limbo_error: LimboError) -> napi::Error {
    napi::Error::new(napi::Status::GenericFailure, format!("{limbo_error}"))
}

#[inline]
fn into_napi_sqlite_error(limbo_error: LimboError) -> napi::Error<String> {
    napi::Error::new(String::from("SQLITE_ERROR"), format!("{limbo_error}"))
}

#[inline]
fn into_napi_error_with_message(
    error_code: String,
    limbo_error: LimboError,
) -> napi::Error<String> {
    napi::Error::new(error_code, format!("{limbo_error}"))
}

#[inline]
fn with_sqlite_error_message(err: napi::Error) -> napi::Error<String> {
    napi::Error::new("SQLITE_ERROR".to_owned(), err.reason.clone())
}

#[inline]
fn into_convertible_type_error_message(error_type: &str) -> String {
    "[TURSO_CONVERT_TYPE] ".to_owned() + error_type
}


